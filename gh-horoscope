#!/bin/bash
 
# gh-horoscope - CLI tool that generates a playful "horoscope" from GitHub activity
# Purpose: contest submission for "For the Lo        read -p "ðŸ”® Choose your mystical path (1-14)[Secrets can be Revealed]: " choicee of Code" (terminal-based UX)
# Comments tailored for judges: concise description for each function. Hidden
# features are acknowledged but their internals are intentionally omitted from
# comments. Sprinkle of human flavor: tears of debugging at 3am may be present.

# Light humor: powered by coffee, curiosity, and the occasional rubber duck.

set -e

# Script directory for relative imports
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source all library modules
source "$SCRIPT_DIR/lib/display.sh"
source "$SCRIPT_DIR/lib/github-analyzer.sh"
source "$SCRIPT_DIR/lib/fortune-data.sh"
source "$SCRIPT_DIR/lib/horoscope-generator.sh"
source "$SCRIPT_DIR/lib/tarot-system.sh"
source "$SCRIPT_DIR/lib/comedy-generator.sh"
source "$SCRIPT_DIR/lib/oracle-sessions.sh"
source "$SCRIPT_DIR/lib/celebrity-comparison.sh"
source "$SCRIPT_DIR/lib/achievements.sh"

# Default values
USERNAME=""
VERBOSE=false
INTERACTIVE=false
COMPARE_MODE=false
EXPORT_FILE=""
QUICK_MODE=false
TAROT_MODE=false
ROAST_MODE=false
COMPLIMENT_MODE=false
ORACLE_MODE=false
ORACLE_TYPE=""
CELEBRITY_MODE=false
DOPPELGANGER_MODE=false
CELEBRITY_NAME=""

# Display usage and help text for the CLI. Keep examples terse and clear.
show_help() {
    cat << EOF
ðŸ”® GitHub CLI Horoscope Extension ðŸ”®

USAGE:
    gh horoscope [OPTIONS] [USERNAME]

OPTIONS:
    -h, --help         Show this help message
    -u, --user         GitHub username (defaults to current authenticated user)
    -v, --verbose      Show detailed analysis data
    -i, --interactive  Interactive mode with mystical questions
    -c, --compare      Compare two users' horoscopes
    -e, --export FILE  Export horoscope to file
    -q, --quick        Quick horoscope mode (essential insights only)
    -t, --tarot        Programming tarot card readings
    -r, --roast        Roast mode - humorous code analysis
    --compliment       Compliment mode - celebrate your coding journey
    -o, --oracle [TYPE] Oracle session - interactive coding wisdom & advice
                        TYPE can be: career-guidance, debugging-wisdom, 
                        burnout-check, skill-development, team-collaboration,
                        project-focus, coding-rhythm, technical-growth,
                        technical-debt, open-source-path, language-mastery
    --version          Show version information
    --doppelganger     Find your celebrity coding doppelganger
    --list-celebrities List all available celebrity developers

EXAMPLES:
    gh horoscope                        # Your own mystical horoscope
    gh horoscope octocat               # Horoscope for user 'octocat'
    gh horoscope -u torvalds -v        # Verbose horoscope for 'torvalds'
    gh horoscope -i                    # Interactive mystical session
    gh horoscope -t                    # Programming tarot card reading
    gh horoscope -o                    # Oracle wisdom session
    gh horoscope -r username           # Roast a developer's code (lovingly)
    gh horoscope --compliment username # Compliment a developer's journey
    gh horoscope --celebrity torvalds  # Compare with Linus Torvalds
    gh horoscope --doppelganger user   # Find celebrity coding twin
    gh horoscope --list-celebrities    # Show all available celebrities
    gh horoscope -c user1 user2        # Compare two developers
    gh horoscope -q -e ~/my_fortune.txt # Quick export
    
DESCRIPTION:
    Generates a personalized horoscope based on your GitHub activity patterns.
    Analyzes your coding habits, commit patterns, repository diversity, and
    more to divine your coding future! âœ¨

    â­ NEW MYSTICAL FEATURES â­
    â€¢ Developer Archetype Analysis ðŸŽ­ (35+ unique archetypes)
    â€¢ Programming Tarot Card System ðŸƒ (complete mystical deck)
    â€¢ Oracle Sessions ðŸ”® (interactive coding wisdom & advice)
    â€¢ Celebrity Developer Comparison ðŸ‘‘ (compare with coding legends)
    â€¢ Coding Doppelganger Finder ðŸŽ­ (find your celebrity twin)
    â€¢ Roast Mode ðŸ”¥ (humorous code analysis with love)
    â€¢ Compliment Mode ðŸ’ (celebrate your coding journey)
    â€¢ Commit Message Mystique ðŸ“œ  
    â€¢ Elemental Coding Nature âš¡
    â€¢ Bug Prophecy & Future Visions ðŸ”®
    â€¢ Time Magic & Coding Rhythms â°
    â€¢ Collaboration Constellation ðŸ¤
    â€¢ Repository Zodiac Signs â™ˆ

    Original features include:
    â€¢ Night Owl Detection ðŸ¦‰
    â€¢ Weekend Warrior Score ðŸ’ª
    â€¢ Repository Personality Reading ðŸ›ï¸
    â€¢ GitHub Karma Analysis âš–ï¸
    â€¢ Lucky Numbers & Coffee Fortunes â˜•

EOF
}

# Interactive session: show a menu and let the user explore features.
# This mode records usage and can unlock achievements; remains non-invasive.
run_interactive_mode() {
    # Record that interactive mode was entered and evaluate achievements
    track_usage "interactive"
    
    # Get username if not provided - prioritize actual GitHub user
    if [[ -z "$USERNAME" ]]; then
        USERNAME=$(gh api user --jq '.login' 2>/dev/null || echo "")
        if [[ -z "$USERNAME" ]]; then
            display_warning "Unable to determine GitHub username automatically."
            display_info "Using demonstration mode with sample data."
            display_info "For real analysis, authenticate with GitHub: gh auth login"
            echo
            USERNAME="demo-user"
        else
            display_info "ðŸ” Interactive mode for GitHub user: $USERNAME"
            echo
        fi
    fi
    
    display_crystal_ball
    echo
    display_mystical_quote "Welcome, secret-seeker, to the interactive realm of code divination..."
    echo
    
    while true; do
        display_interactive_menu
        read -p "ðŸ”® Choose your mystical path (1-14)[Secrets can be Reveled]: " choice
        clear
        # Normalize menu input to be case-insensitive
        shopt -s nocasematch 2>/dev/null || true
        case $choice in
            # If user typed a known easter-egg name, handle it here (case-insensitive)
            "konami"|"konami_code"|"konami-code")
                # Attempt to mark the egg as found and unlock with special celebration
                source "$SCRIPT_DIR/lib/achievements.sh"
                mark_easter_egg_found "konami_code"
                # Quietly record unlock; we'll show the Konami-specific celebration
                unlock_achievement_quiet "konami_code"
                if display_konami_celebration; then
                    continue
                else
                    continue
                fi
                ;;
            "goldeneye"|"golden_eye"|"007"|"bond")
                source "$SCRIPT_DIR/lib/achievements.sh"
                mark_easter_egg_found "goldeneye_007"
                # Quietly record unlock; show GoldenEye-specific celebration
                unlock_achievement_quiet "goldeneye_007"
                if display_goldeneye_celebration; then
                    continue
                else
                    continue
                fi
                ;;
            "nuketown"|"cod_nuketown"|"cod")
                source "$SCRIPT_DIR/lib/achievements.sh"
                mark_easter_egg_found "nuketown_cod"
                unlock_achievement_quiet "nuketown_cod"
                if display_nuketown_celebration; then
                    continue
                else
                    continue
                fi
                ;;
            # Ghost and Secret eggs have been deprecated; only Konami, GoldenEye, and Nuketown remain
            # Other secret handlers removed to keep the experience focused.
            "egg"|"easter"|"easter_egg"|"easter-egg"|"easter_egg_hunter")
                source "$SCRIPT_DIR/lib/achievements.sh"
                mark_easter_egg_found "easter_egg_hunter"
                unlock_achievement "easter_egg_hunter"
                continue
                ;;

    esac

    case $choice in
            1)
                display_archetype_loading
                display_archetype_reveal "The Code Whisperer" "You speak to bugs in their native tongue. Your mystical ability to commune with the deepest mysteries of code allows you to debug problems that perplex mere mortals. Like a digital shaman, you understand the ancient spirits that dwell within loops, conditionals, and recursive functions."
                ;;
            2)
                display_bug_oracle_awakening
                read -p "ðŸ—£ï¸  What question troubles your coding soul? " question
                display_bug_oracle_loading "$question"
                
                # Use the existing Oracle wisdom system to analyze the question
                local response=""
                if [[ "$question" =~ (bug|debug|error|fix|broken|wrong) ]]; then
                    response="${ORACLE_RESPONSES[debugging]}"
                elif [[ "$question" =~ (git|merge|conflict|branch) ]]; then
                    response="ðŸ” **The Git Oracle speaks:** Conflicts are conversations between parallel realities. Listen to both sides, understand their intent, then merge their wisdom. Remember: git reflog is your time machine when reality fractures."
                elif [[ "$question" =~ (performance|slow|speed|optimize) ]]; then
                    response="âš¡ **The Performance Oracle whispers:** Speed is not about doing things fast, but about not doing unnecessary things. Profile before optimizing - assumptions are the mother of all performance bugs. The fastest code is the code that never runs."
                elif [[ "$question" =~ (test|testing|unit|integration) ]]; then
                    response="ðŸ§ª **The Testing Oracle reveals:** Tests are love letters to your future self. They protect your code from chaos and your sleep from anxiety. Write tests that tell the story of what your code should do."
                else
                    # Generic wisdom based on question
                    response="ðŸ”® **The Bug Oracle reflects:** Every question reveals a seeker of truth. Your curiosity is the compass that navigates complexity. The answer often lies not in new knowledge, but in connecting what you already know."
                fi
                
                display_bug_oracle_response "$question" "$response"
                ;;
            3)
                analyze_github_user "$USERNAME"
                clear
                display_daily_prediction
                ;;
            4)
                analyze_github_user "$USERNAME"
                clear
                display_coding_element
                ;;
            5)
                analyze_github_user "$USERNAME"
                clear
                display_commit_analysis
                ;;
            6)
                display_tarot_session
                ;;
            7)
                display_oracle_session
                ;;
            8)
                display_celebrity_session "${USERNAME:-demo-user}"
                ;;
            9)
                display_roast_session "${USERNAME:-demo-user}"
                ;;
            10)
                display_compliment_session "${USERNAME:-demo-user}"
                ;;
            11)
                clear
                display_mystical_loading "Consulting the lunar spirits..." 2
                clear
                display_moon_calendar 15

                ;;
            12)
                display_github_loading "Analyzing your GitHub soul..." 3
                # Don't clear - preserve the header and let horoscope generation continue
                # Exit interactive mode and run full horoscope
                break
                ;;
            13)
                display_achievements_session
                ;;
            14)
                echo -ne "                      ${RED}${BOLD}                    ðŸšª The mystical realm bids you farewell..."
                display_mystical_quote "May your code compile and your bugs be few!"
                exit 0
                ;;
            *)
                echo "â“ The spirits do not understand. Please choose 1-14."
                ;;
        esac
        echo
        read -p "Press Enter to continue your mystical journey..." 
        clear
        echo
    done
}

# Parse CLI arguments and populate global mode variables
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -u|--user)
                USERNAME="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -i|--interactive)
                INTERACTIVE=true
                shift
                ;;
            -c|--compare)
                COMPARE_MODE=true
                # Capture up to two usernames following -c
                if [[ -n "$2" && "$2" != -* ]]; then
                    COMPARE_A="$2"
                    shift
                    if [[ -n "$2" && "$2" != -* ]]; then
                        COMPARE_B="$2"
                        shift
                    fi
                fi
                shift  
                ;;
            -e|--export)
                EXPORT_FILE="$2"
                shift 2
                ;;
            -q|--quick)
                QUICK_MODE=true
                shift
                ;;
            -t|--tarot)
                TAROT_MODE=true
                shift
                ;;
            -r|--roast)
                ROAST_MODE=true
                shift
                ;;
            --compliment)
                COMPLIMENT_MODE=true
                shift
                ;;
            -o|--oracle)
                ORACLE_MODE=true
                # Check if next argument is an oracle type
                if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                    ORACLE_TYPE="$2"
                    shift 2
                else
                    shift
                fi
                ;;
            --version)
                    echo "ðŸ”® GitHub CLI Horoscope Extension v1.0.0."
                echo "For the Love of Code 2025 - Terminal Talent Category"
                echo "Created by CyberNaught-XyZ"
                exit 0
                ;;
            --celebrity)
                CELEBRITY_MODE=true
                CELEBRITY_NAME="$2"
                shift 2
                ;;
            --doppelganger)
                DOPPELGANGER_MODE=true
                shift
                ;;
            --list-celebrities)
                list_celebrities
                exit 0
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                show_help
                exit 1
                ;;
            *)
                if [[ -z "$USERNAME" ]]; then
                    USERNAME="$1"
                fi
                shift
                ;;
        esac
    done
}

# Main entrypoint: route to modes (tarot, oracle, compare, interactive, etc.)
main() {
    parse_args "$@"
    
    # Handle tarot mode
    if [[ "$TAROT_MODE" == "true" ]]; then
        run_tarot_session
        exit 0
    fi
    
    # Handle oracle mode
    if [[ "$ORACLE_MODE" == "true" ]]; then
        # Get username if not provided
        if [[ -z "$USERNAME" ]]; then
            USERNAME=$(gh api user --jq '.login' 2>/dev/null || echo "")
            if [[ -z "$USERNAME" ]]; then
                display_warning "Unable to determine GitHub username automatically."
                display_info "Using demonstration mode with sample data."
                USERNAME="demo-user"
            fi
        fi
        
        # Try to analyze GitHub data first
        if ! analyze_github_user "$USERNAME" 2>/dev/null; then
            display_info "Using sample data for oracle consultation..."
            # Set demo data
            REPO_COUNT=7
            TOTAL_COMMITS=156
            NIGHT_OWL_PERCENTAGE=30
            WEEKEND_PERCENTAGE=20
            PRIMARY_LANGUAGES=("JavaScript" "Python")
            COMMIT_MESSAGES=("fix stuff" "update" "it works now" "refactor code")
        fi
        
        # If specific oracle type was provided, use GitHub-data-driven oracle
        if [[ -n "$ORACLE_TYPE" ]]; then
            analyze_github_oracle "$USERNAME" "$ORACLE_TYPE"
        else
            # Fall back to interactive oracle session
            run_oracle_session
        fi
        exit 0
    fi
    
    # Handle celebrity comparison modes
    if [[ "$CELEBRITY_MODE" == "true" || "$DOPPELGANGER_MODE" == "true" ]]; then
        # Get username if not provided
        if [[ -z "$USERNAME" ]]; then
            USERNAME=$(gh api user --jq '.login' 2>/dev/null || echo "")
            if [[ -z "$USERNAME" ]]; then
                echo "âš ï¸ Unable to determine GitHub username automatically."
                echo "â„¹ï¸ Using demonstration mode with sample data."
                USERNAME="demo-user"
            fi
        fi
        
        # Try to analyze GitHub data - if it fails, continue with demo data
        if ! analyze_github_user "$USERNAME" 2>/dev/null; then
            echo "â„¹ï¸ Using sample data for analysis..."
            # Set demo data
            REPO_COUNT=7
            TOTAL_COMMITS=156
            NIGHT_OWL_PERCENTAGE=30
            WEEKEND_PERCENTAGE=20
            PRIMARY_LANGUAGES=("JavaScript" "Python")
            COMMIT_MESSAGES=("fix stuff" "update" "it works now" "refactor code")
        fi
        
        if [[ "$CELEBRITY_MODE" == "true" ]]; then
            if [[ -n "$CELEBRITY_NAME" ]]; then
                display_celebrity_comparison "$USERNAME" "$CELEBRITY_NAME"
            else
                echo "â— Please specify a celebrity name: gh horoscope --celebrity [name] [username]"
                echo "Use --list-celebrities to see available options."
            fi
        else
            display_coding_doppelganger "$USERNAME"
        fi
        exit 0
    fi
    
    # Handle roast and compliment modes (need username)
    if [[ "$ROAST_MODE" == "true" || "$COMPLIMENT_MODE" == "true" ]]; then
        # Get username if not provided
        if [[ -z "$USERNAME" ]]; then
            USERNAME=$(gh api user --jq '.login' 2>/dev/null || echo "")
            if [[ -z "$USERNAME" ]]; then
                echo "âš ï¸ Unable to determine GitHub username automatically."
                echo "â„¹ï¸ Using demonstration mode with sample data."
                USERNAME="demo-user"
            fi
        fi
        
        # Try to analyze GitHub data - if it fails, continue with demo data
        if ! analyze_github_user "$USERNAME" 2>/dev/null; then
            echo "â„¹ï¸ Using sample data for analysis..."
            # Set demo data for roasting/complimenting
            REPO_COUNT=7
            TOTAL_COMMITS=156
            NIGHT_OWL_PERCENTAGE=30
            WEEKEND_PERCENTAGE=20
            PRIMARY_LANGUAGES=("JavaScript" "Python")
            COMMIT_MESSAGES=("fix stuff" "update" "it works now" "refactor code")
        fi
        
        if [[ "$ROAST_MODE" == "true" ]]; then
            run_roast_mode "$USERNAME"
        else
            run_compliment_mode "$USERNAME"
        fi
        exit 0
    fi
    
    # Handle interactive mode
    if [[ "$INTERACTIVE" == "true" ]]; then
        run_interactive_mode
    fi
    
    # Show header
    display_header
    
    # Get username if not provided
    if [[ -z "$USERNAME" ]]; then
        USERNAME=$(gh api user --jq '.login' 2>/dev/null || echo "")
        if [[ -z "$USERNAME" ]]; then
            display_warning "Unable to determine GitHub username automatically."
            display_info "Using demonstration mode with sample data."
            display_info "For real analysis, provide a username: gh horoscope [username]"
            display_info "Or authenticate with GitHub: gh auth login"
            echo
            USERNAME="demo-user"
        fi
    fi
    
    display_info "ðŸ” Analyzing GitHub patterns for user: $USERNAME"
    echo
    
    # Analyze GitHub data
    if ! analyze_github_user "$USERNAME"; then
        display_error "Failed to analyze GitHub data for user: $USERNAME"
        exit 1
    fi
    
    # Generate horoscope
    if [[ -n "$EXPORT_FILE" ]]; then
        # Export to file
        display_info "ðŸ“œ Exporting horoscope to: $EXPORT_FILE"
        {
            echo "ðŸ”® GITHUB HOROSCOPE for $USERNAME ðŸ”®"
            echo "Generated on: $(date)"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo
            generate_horoscope "$USERNAME" "$VERBOSE"
            echo
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Generated by GitHub CLI Horoscope Extension"
            echo "https://github.com/CyberNaught-XYZ/gh-horoscope"
        } > "$EXPORT_FILE"
        
        display_success "âœ¨ Horoscope exported to $EXPORT_FILE"
        display_mystical_quote "Your digital destiny has been captured in the sacred scrolls!"
    else
        # Display horoscope normally
        generate_horoscope "$USERNAME" "$VERBOSE"
    fi

    # If compare mode was requested, run a lightweight user comparison
    if [[ "$COMPARE_MODE" == "true" ]]; then
        # Determine compare pair
        if [[ -n "$COMPARE_A" && -n "$COMPARE_B" ]]; then
            local a="$COMPARE_A"
            local b="$COMPARE_B"
        elif [[ -n "$COMPARE_A" ]]; then
            # default to local user vs COMPARE_A
            local a="$USERNAME"
            local b="$COMPARE_A"
        else
            # nothing specified, nothing to compare
            a=""
            b=""
        fi

        if [[ -n "$a" && -n "$b" ]]; then
            display_info "ðŸ”Ž Comparing $a vs $b..."
            # Call comparator: expects first line numeric score, then a short REASONS block
            local compare_output
            compare_output=$(compare_two_users "$a" "$b" 2>/dev/null || echo -e "0\nREASONS:\nâ€¢ Comparison failed or timed out")

            # Extract first line as score and the rest as reasons
            local pct
            pct=$(echo "$compare_output" | head -n1)

            echo
            echo "    âž¤ Your horoscope similarity: ${pct}% (between $a and $b)"
            echo

            # Prepare reasons block
            local reasons_block
            reasons_block=$(echo "$compare_output" | sed -n '2,$p')

            # Display under bordered mystical section style
            echo -e "\n"
            echo -e "${CYAN}${BOLD}"
            display_mystical_section "ðŸ”Ž Comparison Reasons"
            echo -e "${WHITE}"
            # Print reasons with proper wrapping and indentation
            echo "$reasons_block" | sed '/^$/d' | while IFS= read -r line; do
                # Remove any leading REASONS: label
                if [[ "$line" =~ ^REASONS: ]]; then
                    continue
                fi
                # Ensure each reason line is wrapped similarly to other sections
                echo "    $line" | fold -s -w 75 | sed '1!s/^/      /'
            done
            echo -e "${RESET}\n"
        else
            display_warning "Compare mode selected but no usernames provided. Use: -c userA [userB]"
        fi
    fi
    
    # Show footer
    display_footer
}

# Run main function
main "$@"